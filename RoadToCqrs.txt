Introduction

What it is
•	Based on CQS from Myeres (1996)
	•	Command Query Separation
	•	For each Entity has a Command Method and a Query Mehtod
•	Defined by Fowler in 2001
	•	Command Query Responsibility Segregation
	•	For each Entity has separate Write and Read Model

Inspirations
•	DDD: Increases the Domain concept to Write and Read Models
•	Actors Model:
	•	Every Domain has its own indipendent storage
	•	The Domain state is changeable and visible by the external environment only through Messages
•	Microservices: The Read and Write models are isolated services

Let’s start

Cruise Domain
•	Should create Cruises
•	Should allow to add unique Rooms with a category
•	Should show all the rooms by Cruise/Category

T01: Aggregate Root
•	Is the main Business Entity
•	Given Command Methods produces Events
•	Contains all the data needed by the Business Logic
•	The name comes from the DDD terminology

T02: Write Model
•	Should store the data in the easiest possible form. Typically serialized

T02: Entity Storage
•	Stores basically Id, and Serialized Data
•	This is the “Single source of truth” of the application

T02: Command Handler
•	Receive the requests from a Queue in form of messages
•	Is the only entry point to access the Aggregate Root
•	Handle all the storage duties for the Aggregate

T02: Command
•	Expressed in imperative like “Create Cruise”
•	Contains all the data needed by the Write Model

T02: Command Handlers
•	Handles the Commands
•	Read and writes the data on the Write Model
•	After saving on Storage the Write Model publishes Events

T02: Events
•	They are notifications of what is happened on the Write Model
•	Expressed in Past Tense “Cruise Created”
•	They cannot change the state of the Write Model
•	Contains all data changed by the Write Model
•	They can be spread through Topics

The read model

T03: Bus
•	Used to send Commands to the Command Handlers
•	Send the Events to the Read Model
•	Introduces the Eventual Consistency

T04: Read (Query) Model
•	Ideally there is one Read Model for each type query
•	Represents the data in the form easiest to search with
•	It's like a “Materialized View”

T04: Event Handlers (Projections)
•	They build the Read Model
•	The receive events and create a view on data
•	Are similar to Data Warehouse system but in “Real-Time”

The Mythical Real Time Db
•	Databases CANNOT BE Real-Time
•	CQRS CANNOT BE Real-Time but admits it via the “Eventual Consistency”
•	This means that the Read Model is not “instantly” updated

Multiple Users

T05: Optimistic lock 
•	We introduce on the Entity Storage the Version
•	The updates will be made with Id and Version
•	When the update worked on one (1) item the operation is considered successful
•	Otherwise an exception is thrown
•	The command must specify the version of the Aggregate Root on which they work and this will be verified by the Storage
 
Invoices And Customers 
•	Should create Invoices associated with Customers
•	When Emitting an Invoice should store the Billing Address, that could not be changed

T06: Referencing External Domains
•	All external Aggregate Roots (or Crud items) must be referenced by Id
•	The Event Handlers can retrieve the linked items data and store it to reduce the Query complexity
•	The Command Handlers will access the proxied services exposed by the other domains

T07: Value Objects
•	To store “invariants” like and Address will be used the Value Object concept
•	A Value Object is an Object whose Natural Key is the whole object: does not break the rule of referring to external items via Id only

Warehouse and Payment, inside our application
•	Identify the Domain of Warehouse allowing to Reserve Items
•	When a Payment is started a request is issued to Reserve Items
•	Contextually an Expire event is issued

T08: Distributed transaction
•	The Warehouse Domain handles the Expiration of Reservation by itself
•	The Payment Domain, when creating a Payment send a Delayed Expiration message
•	If the Expiration arrives with the Payment still reserving the Payment is canceled

Warehouse and Payment, crossing boundaries
•	The PayPal service is exposed via a Proxy
•	When Reservation or PayPal Payment fails the Payment is canceled

T09: Distributed transaction 
•	The PayPal Proxy service is called inside the Command Handler to hide its data from the Aggregate
•	The PayPal Proxy service will send a message when the payment fails or succeed
•	When the Payment expire and no answer exists from PayPal the system tries to cancel the payment compulsively
 
The Red Pill

What we have seen until now is only a toy implementation. Several issues should be addressed e.g. (but not limited to): 
Bus failures: in these examples we assume the bus never fails. We should use a subsystem that handles these situations, like a retry policy to send the Events or an XA between an RDBMS and the Bus
The distributed transactions or better “sagas” would be handled easily with a State Machine. Some Service Bus implementation offers even specific DSLs to ease the solution.
The “toxic” messages will be sent typically on the “Dead Letter” queues. Someone should take care of them!
Use only when fitting: an example would be a Tree data structure. Sometimes the effort to build a Domain is simply too big

References and Contacs

•	Enrico Da Ros
	•	Github: https://github.com/kendarorg
	•	Linkedin: https://linkedin.com/enricodaros 
Eric Evans, Domain-Driven Design, Addison-Wesley, 2003
Jimmy Nilsson, Applying Domain-Driven Design and Patterns, Pearson, 2006
Vaughn Vernon, Implementing Domain Driven Design, Pearson, 2013
NServiceBus, https://particular.net/nservicebus
Martin Folwer, https://martinfowler.com/
Jimmy Bogard, https://jimmybogard.com/


